#!/usr/bin/env python3
"""
Script de validation compl√®te du menu Certification FNE
========================================================

Ce script v√©rifie que tous les composants du menu Certification FNE 
fonctionnent correctement apr√®s les corrections d'architecture :

1. Navigation entre sous-menus
2. Chargement des ViewModels
3. Syst√®me de logging centralis√©
4. Injection de d√©pendances
5. Coh√©rence des donn√©es

Auteur: Assistant IA
Date: D√©cembre 2024
"""

import sqlite3
import os
import sys
from datetime import datetime
import json

# Configuration
DB_PATH = r"d:\PROJET\FNE\FNEV4\Data\Database\fnev4_centralised.db"
LOG_DIR = r"d:\PROJET\FNE\FNEV4\Data\Logs"

def check_database_connection():
    """V√©rifier la connexion √† la base de donn√©es"""
    print("üîç === V√âRIFICATION DE LA BASE DE DONN√âES ===")
    
    if not os.path.exists(DB_PATH):
        print(f"‚ùå Base de donn√©es introuvable: {DB_PATH}")
        return False
    
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # V√©rifier les tables essentielles
        tables_required = ['Invoices', 'FneConfigurations', 'InvoicesFne']
        for table in tables_required:
            cursor.execute(f"SELECT COUNT(*) FROM {table}")
            count = cursor.fetchone()[0]
            print(f"‚úÖ Table {table}: {count} enregistrements")
        
        conn.close()
        print("‚úÖ Connexion base de donn√©es r√©ussie")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur base de donn√©es: {e}")
        return False

def check_certification_data():
    """V√©rifier les donn√©es de certification"""
    print("\nüìä === ANALYSE DES DONN√âES CERTIFICATION ===")
    
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # Statistiques factures
        cursor.execute("""
            SELECT 
                Status,
                COUNT(*) as count,
                SUM(CASE WHEN Amount IS NOT NULL THEN Amount ELSE 0 END) as total_amount
            FROM Invoices 
            GROUP BY Status
        """)
        
        print("üìã R√©partition des factures par statut:")
        total_invoices = 0
        for status, count, amount in cursor.fetchall():
            total_invoices += count
            print(f"   ‚Ä¢ {status}: {count} factures (Total: {amount:.2f}‚Ç¨)")
        
        print(f"\nüìà Total factures: {total_invoices}")
        
        # Configurations FNE actives
        cursor.execute("SELECT COUNT(*) FROM FneConfigurations WHERE IsActive = 1")
        active_configs = cursor.fetchone()[0]
        print(f"‚öôÔ∏è Configurations FNE actives: {active_configs}")
        
        # Factures certifi√©es FNE
        cursor.execute("""
            SELECT 
                COUNT(*) as certified_count,
                COUNT(CASE WHEN CertificationStatus = 'Success' THEN 1 END) as success_count,
                COUNT(CASE WHEN CertificationStatus = 'Error' THEN 1 END) as error_count
            FROM InvoicesFne
        """)
        
        certified, success, errors = cursor.fetchone()
        if certified > 0:
            print(f"üèÜ Certifications FNE: {certified} total ({success} r√©ussies, {errors} erreurs)")
        else:
            print("‚ÑπÔ∏è Aucune certification FNE trouv√©e")
        
        conn.close()
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur analyse donn√©es: {e}")
        return False

def check_logging_system():
    """V√©rifier le syst√®me de logging centralis√©"""
    print("\nüìù === V√âRIFICATION SYST√àME LOGGING ===")
    
    if not os.path.exists(LOG_DIR):
        print(f"‚ùå R√©pertoire de logs introuvable: {LOG_DIR}")
        return False
    
    print(f"‚úÖ R√©pertoire de logs: {LOG_DIR}")
    
    # Chercher les fichiers de logs r√©cents
    today = datetime.now().strftime("%Y%m%d")
    log_file_today = os.path.join(LOG_DIR, f"FNEV4_{today}.log")
    
    log_files = []
    for file in os.listdir(LOG_DIR):
        if file.startswith("FNEV4_") and file.endswith(".log"):
            log_files.append(file)
    
    print(f"üìÅ Fichiers de logs disponibles: {len(log_files)}")
    
    if log_files:
        latest_log = max(log_files)
        latest_path = os.path.join(LOG_DIR, latest_log)
        
        if os.path.exists(latest_path):
            size = os.path.getsize(latest_path)
            print(f"üìÑ Dernier log: {latest_log} ({size} bytes)")
            
            # V√©rifier le contenu pour des entr√©es Certification
            try:
                with open(latest_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    certification_logs = content.count("Certification")
                    fne_logs = content.count("FNE")
                    print(f"üîç Entr√©es li√©es √† Certification: {certification_logs}")
                    print(f"üîç Entr√©es li√©es √† FNE: {fne_logs}")
            except Exception as e:
                print(f"‚ö†Ô∏è Impossible de lire le log: {e}")
    
    return True

def check_viewmodel_architecture():
    """V√©rifier l'architecture des ViewModels"""
    print("\nüèóÔ∏è === V√âRIFICATION ARCHITECTURE VIEWMODELS ===")
    
    # Chemins des ViewModels Certification FNE
    viewmodels = {
        "CertificationMainViewModel": r"d:\PROJET\FNE\FNEV4\src\FNEV4.Presentation\ViewModels\CertificationFne\CertificationMainViewModel.cs",
        "CertificationDashboardViewModel": r"d:\PROJET\FNE\FNEV4\src\FNEV4.Presentation\ViewModels\CertificationFne\CertificationDashboardViewModel.cs", 
        "CertificationManuelleViewModel": r"d:\PROJET\FNE\FNEV4\src\FNEV4.Presentation\ViewModels\CertificationFne\CertificationManuelleViewModel.cs",
        "CertificationAutomatiqueViewModel": r"d:\PROJET\FNE\FNEV4\src\FNEV4.Presentation\ViewModels\CertificationFne\CertificationAutomatiqueViewModel.cs"
    }
    
    architecture_checks = {
        "ILoggingService": 0,
        "NavigationItems": 0,
        "ObservableProperty": 0,
        "async Task": 0
    }
    
    for vm_name, vm_path in viewmodels.items():
        if os.path.exists(vm_path):
            print(f"‚úÖ {vm_name}: Fichier trouv√©")
            
            try:
                with open(vm_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                    # V√©rifications d'architecture
                    if "ILoggingService" in content:
                        architecture_checks["ILoggingService"] += 1
                        print(f"   ‚úì Utilise ILoggingService")
                    
                    if "NavigationItems" in content:
                        architecture_checks["NavigationItems"] += 1
                        print(f"   ‚úì Syst√®me de navigation")
                    
                    if "ObservableProperty" in content:
                        architecture_checks["ObservableProperty"] += 1
                        print(f"   ‚úì MVVM Toolkit")
                    
                    if "async Task" in content:
                        architecture_checks["async Task"] += 1
                        print(f"   ‚úì M√©thodes asynchrones")
                        
            except Exception as e:
                print(f"   ‚ùå Erreur lecture: {e}")
        else:
            print(f"‚ùå {vm_name}: Fichier introuvable")
    
    print(f"\nüìä R√©sum√© architecture:")
    for check, count in architecture_checks.items():
        print(f"   ‚Ä¢ {check}: {count}/4 ViewModels")
    
    return True

def check_dependency_injection():
    """V√©rifier la configuration d'injection de d√©pendances"""
    print("\nüíâ === V√âRIFICATION INJECTION D√âPENDANCES ===")
    
    app_xaml_path = r"d:\PROJET\FNE\FNEV4\src\FNEV4.Presentation\App.xaml.cs"
    
    if not os.path.exists(app_xaml_path):
        print(f"‚ùå App.xaml.cs introuvable: {app_xaml_path}")
        return False
    
    print("‚úÖ App.xaml.cs trouv√©")
    
    try:
        with open(app_xaml_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
            # V√©rifications DI
            checks = {
                "CertificationMainViewModel": "CertificationMainViewModel" in content,
                "CertificationDashboardViewModel": "CertificationDashboardViewModel" in content,
                "CertificationAutomatiqueViewModel": "CertificationAutomatiqueViewModel" in content,
                "ILoggingService": "ILoggingService" in content,
                "AddTransient": "AddTransient" in content
            }
            
            for check, result in checks.items():
                status = "‚úÖ" if result else "‚ùå"
                print(f"   {status} {check}")
            
            return all(checks.values())
            
    except Exception as e:
        print(f"‚ùå Erreur lecture App.xaml.cs: {e}")
        return False

def generate_test_instructions():
    """G√©n√©rer les instructions de test manuel"""
    print("\nüéÆ === INSTRUCTIONS TEST MANUEL ===")
    
    instructions = [
        "1. Compiler et lancer FNEV4.Presentation",
        "2. Naviguer vers le menu 'Certification FNE'",
        "3. V√©rifier l'affichage du tableau de bord",
        "4. Tester la navigation vers 'Certification manuelle'",
        "5. V√©rifier le chargement des factures disponibles", 
        "6. Tester la navigation vers 'Certification automatique'",
        "7. V√©rifier les options de configuration automatique",
        "8. Contr√¥ler les logs dans Data\\Logs\\FNEV4_YYYYMMDD.log",
        "9. Valider l'absence d'erreurs de navigation",
        "10. Confirmer la coh√©rence des donn√©es affich√©es"
    ]
    
    for instruction in instructions:
        print(f"   {instruction}")
    
    print("\nüí° Points d'attention:")
    print("   ‚Ä¢ Les temps de chargement doivent √™tre raisonnables")
    print("   ‚Ä¢ Aucune exception dans les logs")
    print("   ‚Ä¢ Navigation fluide entre sous-menus")
    print("   ‚Ä¢ Donn√©es coh√©rentes dans toutes les vues")

def main():
    """Fonction principale du script de validation"""
    print("üöÄ === VALIDATION CERTIFICATION FNE COMPL√àTE ===")
    print(f"Heure de d√©marrage: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)
    
    # Ex√©cuter toutes les v√©rifications
    checks = [
        ("Base de donn√©es", check_database_connection),
        ("Donn√©es de certification", check_certification_data),
        ("Syst√®me de logging", check_logging_system),
        ("Architecture ViewModels", check_viewmodel_architecture),
        ("Injection d√©pendances", check_dependency_injection)
    ]
    
    results = {}
    
    for check_name, check_func in checks:
        try:
            results[check_name] = check_func()
        except Exception as e:
            print(f"‚ùå Erreur lors de {check_name}: {e}")
            results[check_name] = False
    
    # R√©sum√© final
    print("\n" + "=" * 60)
    print("üéØ === R√âSUM√â VALIDATION ===")
    
    passed = 0
    total = len(checks)
    
    for check_name, result in results.items():
        status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHEC"
        print(f"   {check_name}: {status}")
        if result:
            passed += 1
    
    print(f"\nüìä Score global: {passed}/{total} ({(passed/total)*100:.1f}%)")
    
    if passed == total:
        print("\nüéâ SUCC√àS COMPLET!")
        print("Le menu Certification FNE est pr√™t pour les tests utilisateur.")
    else:
        print(f"\n‚ö†Ô∏è {total - passed} v√©rification(s) ont √©chou√©.")
        print("Consulter les d√©tails ci-dessus pour les corrections n√©cessaires.")
    
    # Instructions de test
    generate_test_instructions()
    
    print("\n" + "=" * 60)
    print(f"Validation termin√©e: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

if __name__ == "__main__":
    main()